package Homework3;

public class BinarySearchTree<T> extends BinaryTree<T> implements SearchTreeInterface<T>{
	
	public BinarySearchTree() {
		super();
	}//end default constructor
	
	public BinarySearchTree(T rootEntry) {
		super();
		setRootNode(new BinaryNode<T>(rootEntry));
	}//end default constructor
	
	
	public T getEntry(T entry) {
		return findEntry(getRootNode(), entry);
	}
	
	private T findEntry(BinaryNode<T> rootNode, T entry) {
		T result = null;
		
		if(rootNode != null) {
			T rootEntry = rootNode.getData();
			if(entry.equals(rootEntry))
				result = rootEntry;
			else if(entry.compareTo(rootEntry) < 0)
				result = findEntry(rootNode.getLeftChild(), entry);
			else
				result = findEntry(rootNode.getRightChild(), entry);
		}
	}//end findEntry
	public T add(T newEntry) {
		T result = null;
		if(isEmpty())
			setRootNode(new BinaryNode<T>(newEntry));
		else
			result = addEntry(getRootNode(), newEntry);
		return result;
	}
	private T addEntry(BinaryNodeInterface<T> rootNode, T newEntry) {
		assert currentNode != null;
		T result = null;
		int comparison = newEntry.compareTo(rootNode.getData());
		
		if(comparison == 0) {
			result = rootNode.getData();
			rootNode.setData(newEntry);
		}
		else if(comparison < 0) {
			if(rootNode.hasLeftChild())
				result = addEntry(rootNode.getLeftChild(), newEntry);
			else
				rootNode.setLeftChild(new BinaryNode<T>(newEntry));
		}
		else {
			assert comparison > 0;
			if(rootNode.hasRightChild())
				result = addEntry(rootNode.getRightChild(), newEntry);
			else
				rootNode.setRightChild(new BinaryNode<T>(newEntry));
		}
		
		return result;
	}
	
	private BinaryNodeInterface<T> removeEntry(BinaryNodeInterface<T> rootNode, T entry, ReturnObject oldEntry){
		if(rootNode != null) {
			T rootData = rootNode.getData();
			int comparison = entry.compareTo(rootData);
			if(comparison == 0) {
				oldEntry.set(rootData);
				rootNode = removeFromRoot(rootNode)l
			}
			else if(comparison < 0) {
				BinaryNodeInterface<T> leftChild = rootNode.getLeftChild();
				BinaryNodeInterface<T> subtreeRoot = removeEntry(leftChild,entry,oldEntry);
				rootNode.setLeftChild(subtreeRoot);
			}
			else {
				BinaryNodeInterface<T> rightChild = rootNode.getRightChild();
				rootNode.setRightChild(removeEntry(rightChild,entry,oldEntry));
			}
		}
		return rootNode;
	}
	
	private BinaryNodeInterface<T> removeFromRoot(BinaryNodeInterface<T> rootNode){
		// case 1 : rootNode has 2 children
		if(rootNode.hasLeftChild() && rootNode.hasRightChild()) {
			BinaryNodeInterface<T> leftSubtreeRoot = rootNode.getLeftChild();
			BinaryNodeInterface<T> largestNode = findLarges9LeftSubtreeRoot);
			
			//replace entry in root
			rootNode.setData(largestNode.getDataa());
			
			//remove node with largest entry in left subtree
			rootNode.setLeftChild(removeLargest(leftSubtreeRoot));
		}
		// case 2 : rootNode has at most one child
		else if(rootNode.hasRightChld())
			rootNode = rootNode.getRightChild();
		else 
			rootNode = rootNode.getLeftChild();
		
		return rootNode;
	}


	
	
}
